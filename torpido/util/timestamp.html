<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>torpido.util.timestamp API documentation</title>
<meta name="description" content="This file will read the ranking for each section, parse it and
create timestamps in seconds that can be used to clip the video
using ffmpeg …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>torpido.util.timestamp</code></h1>
</header>
<section id="section-intro">
<p>This file will read the ranking for each section, parse it and
create timestamps in seconds that can be used to clip the video
using ffmpeg.</p>
<pre><code>1. Reading the ranks and parsing them to timestamps
2. Padding the time ranks to generate the timestamps
3. Validating the timestamps
4. Returning a list of list containing (start -&gt; end) time stamps
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This file will read the ranking for each section, parse it and
create timestamps in seconds that can be used to clip the video
using ffmpeg.

    1. Reading the ranks and parsing them to timestamps
    2. Padding the time ranks to generate the timestamps
    3. Validating the timestamps
    4. Returning a list of list containing (start -&gt; end) time stamps

&#34;&#34;&#34;

import numpy as np

from torpido.config import *
from torpido.exceptions import RankingOfFeatureMissing


def addPadding(rankList: list, length):
    &#34;&#34;&#34;
    Function to add padding to the ranks if there length is lower than that of the
    required length
    Average of the rank is added as the padding data, mostly data is below 1

    Parameters
    ----------
    rankList : list
        feature rank list
    length : int
        required length
    &#34;&#34;&#34;
    rankList.extend([np.average(rankList)] * int(length - len(rankList)))


def readTheRankings():
    &#34;&#34;&#34;
    Reads the ranking using the joblib files and calculate
    the final sum ranks

    Getting the ranking length for the ranks for the features from max
    of all the ranks length

    Padding the ranks, so that every feature has equal range

    Returns
    -------
    list
        list of the sum of all ranks
    &#34;&#34;&#34;
    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_MOTION)) is False:
        Log.e(&#34;Motion Ranking does not exists&#34;)
        return None

    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_BLUR)) is False:
        Log.e(&#34;Blur Ranking does not exists&#34;)
        return None

    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_TEXT)) is False:
        Log.e(&#34;Text Ranking does not exists&#34;)
        return None

    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_AUDIO)) is False:
        Log.e(&#34;Audio Ranking does not exists&#34;)
        return None

    # reading the saved ranking from the joblib files
    motionFile = os.path.join(RANK_DIR, RANK_OUT_MOTION)
    blurFile = os.path.join(RANK_DIR, RANK_OUT_BLUR)
    textFile = os.path.join(RANK_DIR, RANK_OUT_TEXT)
    audioFile = os.path.join(RANK_DIR, RANK_OUT_AUDIO)

    # loading the read files
    motionRank = load(motionFile)
    blurRank = load(blurFile)
    textRank = load(textFile)
    audioRank = load(audioFile)

    # max length for ranking
    # NOTE: FFmpeg does not get bothered by greater values, not lower though
    maxRank = int(max(len(motionRank), len(blurRank),
                      len(audioRank), len(textRank)))

    # padding the ranks of each feature
    addPadding(motionRank, maxRank)
    addPadding(blurRank, maxRank)
    addPadding(audioRank, maxRank)
    addPadding(textRank, maxRank)

    return [motionRank, blurRank,
            textRank, audioRank]


def trimByRank(ranks):
    &#34;&#34;&#34;
    Parse the ranks to generate timestamps. Ranks are per sec so the start rank will be start
    timestamp for trimming

    Parameters
    ----------
    ranks : iterable
        ranks of the video

    Returns
    --------
    timestamps : list
        timestamps parsed from the ranks
    &#34;&#34;&#34;
    timestamps = []
    start = None
    end = None
    prev_end = 0
    for i in range(0, len(ranks)):
        if ranks[i] &gt; MIN_RANK_OUT_VIDEO:
            if start is None:
                start = i
            prev_end += 1

        else:
            if end is None and start is not None:
                end = start + prev_end - 1
                if start == end:
                    end = None

        if start is not None and end is not None:
            start = start
            end = end
            timestamps.append([start, end])
            end = None
            start = None
            prev_end = 0

    if start is not None and end is None:
        end = len(ranks)
        timestamps.append([start, end])

    return timestamps


def getTimestamps():
    &#34;&#34;&#34;
    Returns parsed timestamps from the ranking of all 4 processing

    Returns
    -------
    list of list
        timestamps list containing start and emd timestamps

    &#34;&#34;&#34;
    motion, blur, text, audio = readTheRankings()
    ranks = [motion[i] + blur[i] + text[i] + audio[i] for i in range(len(motion))]

    if ranks is not None:
        timestamps = trimByRank(ranks)
    else:
        raise RankingOfFeatureMissing

    finalTimestamp = []

    # validating if there are 2 values in list
    for clip in timestamps:
        if len(clip) % 2 == 0:
            finalTimestamp.append(clip)

    return finalTimestamp


def getOutputVideoLength(timestamps: list):
    &#34;&#34;&#34;
    Calculates the output video length from the timestamps, each portion
    length would be end - start

    Parameters
    ----------
    timestamps : list
        timestamps for the video to edit

    Returns
    -------
    int
        final video length

    References
    ----------

    timestamps has list of start and end like :

        [[start, end], [start, end]]

    to get a length of each portion
        end - start

    to get final length
        finalLength += end[i] - start[i] ; i: 0 -&gt; len(timestamps)
    &#34;&#34;&#34;
    videoLength = 0
    if len(timestamps) &lt; 0:
        return 0

    for start, end in timestamps:
        videoLength += abs(end - start)

    return videoLength</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="torpido.util.timestamp.addPadding"><code class="name flex">
<span>def <span class="ident">addPadding</span></span>(<span>rankList: list, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add padding to the ranks if there length is lower than that of the
required length
Average of the rank is added as the padding data, mostly data is below 1</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rankList</code></strong> :&ensp;<code>list</code></dt>
<dd>feature rank list</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>required length</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addPadding(rankList: list, length):
    &#34;&#34;&#34;
    Function to add padding to the ranks if there length is lower than that of the
    required length
    Average of the rank is added as the padding data, mostly data is below 1

    Parameters
    ----------
    rankList : list
        feature rank list
    length : int
        required length
    &#34;&#34;&#34;
    rankList.extend([np.average(rankList)] * int(length - len(rankList)))</code></pre>
</details>
</dd>
<dt id="torpido.util.timestamp.getOutputVideoLength"><code class="name flex">
<span>def <span class="ident">getOutputVideoLength</span></span>(<span>timestamps: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the output video length from the timestamps, each portion
length would be end - start</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>list</code></dt>
<dd>timestamps for the video to edit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>final video length</dd>
</dl>
<h2 id="references">References</h2>
<p>timestamps has list of start and end like :</p>
<pre><code>[[start, end], [start, end]]
</code></pre>
<p>to get a length of each portion
end - start</p>
<p>to get final length
finalLength += end[i] - start[i] ; i: 0 -&gt; len(timestamps)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOutputVideoLength(timestamps: list):
    &#34;&#34;&#34;
    Calculates the output video length from the timestamps, each portion
    length would be end - start

    Parameters
    ----------
    timestamps : list
        timestamps for the video to edit

    Returns
    -------
    int
        final video length

    References
    ----------

    timestamps has list of start and end like :

        [[start, end], [start, end]]

    to get a length of each portion
        end - start

    to get final length
        finalLength += end[i] - start[i] ; i: 0 -&gt; len(timestamps)
    &#34;&#34;&#34;
    videoLength = 0
    if len(timestamps) &lt; 0:
        return 0

    for start, end in timestamps:
        videoLength += abs(end - start)

    return videoLength</code></pre>
</details>
</dd>
<dt id="torpido.util.timestamp.getTimestamps"><code class="name flex">
<span>def <span class="ident">getTimestamps</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns parsed timestamps from the ranking of all 4 processing</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>list</code></dt>
<dd>timestamps list containing start and emd timestamps</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTimestamps():
    &#34;&#34;&#34;
    Returns parsed timestamps from the ranking of all 4 processing

    Returns
    -------
    list of list
        timestamps list containing start and emd timestamps

    &#34;&#34;&#34;
    motion, blur, text, audio = readTheRankings()
    ranks = [motion[i] + blur[i] + text[i] + audio[i] for i in range(len(motion))]

    if ranks is not None:
        timestamps = trimByRank(ranks)
    else:
        raise RankingOfFeatureMissing

    finalTimestamp = []

    # validating if there are 2 values in list
    for clip in timestamps:
        if len(clip) % 2 == 0:
            finalTimestamp.append(clip)

    return finalTimestamp</code></pre>
</details>
</dd>
<dt id="torpido.util.timestamp.readTheRankings"><code class="name flex">
<span>def <span class="ident">readTheRankings</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the ranking using the joblib files and calculate
the final sum ranks</p>
<p>Getting the ranking length for the ranks for the features from max
of all the ranks length</p>
<p>Padding the ranks, so that every feature has equal range</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of the sum of all ranks</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readTheRankings():
    &#34;&#34;&#34;
    Reads the ranking using the joblib files and calculate
    the final sum ranks

    Getting the ranking length for the ranks for the features from max
    of all the ranks length

    Padding the ranks, so that every feature has equal range

    Returns
    -------
    list
        list of the sum of all ranks
    &#34;&#34;&#34;
    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_MOTION)) is False:
        Log.e(&#34;Motion Ranking does not exists&#34;)
        return None

    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_BLUR)) is False:
        Log.e(&#34;Blur Ranking does not exists&#34;)
        return None

    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_TEXT)) is False:
        Log.e(&#34;Text Ranking does not exists&#34;)
        return None

    if os.path.isfile(os.path.join(RANK_DIR, RANK_OUT_AUDIO)) is False:
        Log.e(&#34;Audio Ranking does not exists&#34;)
        return None

    # reading the saved ranking from the joblib files
    motionFile = os.path.join(RANK_DIR, RANK_OUT_MOTION)
    blurFile = os.path.join(RANK_DIR, RANK_OUT_BLUR)
    textFile = os.path.join(RANK_DIR, RANK_OUT_TEXT)
    audioFile = os.path.join(RANK_DIR, RANK_OUT_AUDIO)

    # loading the read files
    motionRank = load(motionFile)
    blurRank = load(blurFile)
    textRank = load(textFile)
    audioRank = load(audioFile)

    # max length for ranking
    # NOTE: FFmpeg does not get bothered by greater values, not lower though
    maxRank = int(max(len(motionRank), len(blurRank),
                      len(audioRank), len(textRank)))

    # padding the ranks of each feature
    addPadding(motionRank, maxRank)
    addPadding(blurRank, maxRank)
    addPadding(audioRank, maxRank)
    addPadding(textRank, maxRank)

    return [motionRank, blurRank,
            textRank, audioRank]</code></pre>
</details>
</dd>
<dt id="torpido.util.timestamp.trimByRank"><code class="name flex">
<span>def <span class="ident">trimByRank</span></span>(<span>ranks)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the ranks to generate timestamps. Ranks are per sec so the start rank will be start
timestamp for trimming</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ranks</code></strong> :&ensp;<code>iterable</code></dt>
<dd>ranks of the video</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>list</code></dt>
<dd>timestamps parsed from the ranks</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trimByRank(ranks):
    &#34;&#34;&#34;
    Parse the ranks to generate timestamps. Ranks are per sec so the start rank will be start
    timestamp for trimming

    Parameters
    ----------
    ranks : iterable
        ranks of the video

    Returns
    --------
    timestamps : list
        timestamps parsed from the ranks
    &#34;&#34;&#34;
    timestamps = []
    start = None
    end = None
    prev_end = 0
    for i in range(0, len(ranks)):
        if ranks[i] &gt; MIN_RANK_OUT_VIDEO:
            if start is None:
                start = i
            prev_end += 1

        else:
            if end is None and start is not None:
                end = start + prev_end - 1
                if start == end:
                    end = None

        if start is not None and end is not None:
            start = start
            end = end
            timestamps.append([start, end])
            end = None
            start = None
            prev_end = 0

    if start is not None and end is None:
        end = len(ranks)
        timestamps.append([start, end])

    return timestamps</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="torpido.util" href="index.html">torpido.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="torpido.util.timestamp.addPadding" href="#torpido.util.timestamp.addPadding">addPadding</a></code></li>
<li><code><a title="torpido.util.timestamp.getOutputVideoLength" href="#torpido.util.timestamp.getOutputVideoLength">getOutputVideoLength</a></code></li>
<li><code><a title="torpido.util.timestamp.getTimestamps" href="#torpido.util.timestamp.getTimestamps">getTimestamps</a></code></li>
<li><code><a title="torpido.util.timestamp.readTheRankings" href="#torpido.util.timestamp.readTheRankings">readTheRankings</a></code></li>
<li><code><a title="torpido.util.timestamp.trimByRank" href="#torpido.util.timestamp.trimByRank">trimByRank</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>